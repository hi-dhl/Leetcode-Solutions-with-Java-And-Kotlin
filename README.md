# Leetcode-Solutions-with-Java-And-Kotlin

![](http://cdn.51git.cn/2020-05-31-15902373255635.jpg)

**仓库状态：持续更新中**

* 题目进度：AC 70 题
* 仓库题解：二叉树(11)、剑指offer(5)、二分查找(3)、线性查找(1)、数组(2)、链表(1)

数据结构和算法是每个程序的都必须掌握的，也是面试的入门门槛之一，在大学期间经常参加一些比赛如蓝桥杯、ACM 等等，因此无论在面试还是工作都带来很多帮助

Google 这几年一直在强力推荐 Kotlin，自从用了 Kotlin 了之后爱不释手，工作效率提高了很多，现在我打算重拾 LeetCode 之 Algorithm，语言选择 **Java、Kotlin**，目前已经 AC 了 70 题左右，题库会一点点去完善

LeetCode 我现在正式从国际版切换到国内版，因为国内版本现在越做越好了，题库也更加完善，除了基本的算法、数据库、Shell、多线程之外，还有程序员面试宝典、剑指 offer 系列题目，另外不仅可以看全球排名，还可以看国内排名

LeetCode 的题库庞大，每个分类都能筛选出数百道题，由于每个人的精力有限，不可能刷完所有题目，因此我会按照经典类型题目去分类、和题目的难易程度去排序

* 数据结构： 数组、栈、队列、字符串、链表、树……
* 算法： 查找算法、搜索算法、位运算、排序、数学、……

每道题目都会用 Java 和 kotlin 去实现，并且每道题目都有解题思路，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：[Leetcode-Solutions-with-Java-And-Kotlin](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin)，一起来学习，期待与你一起成长

## LeetCode剑指offer（持续更新中）

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-: | :-: | :-: | :-: | 
| 03 | [数组中重复的数字](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/%E5%89%91%E6%8C%87offer/0xF01%20LeetCode%E5%89%91%E6%8C%87offer%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.md)|  [中文地址](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)| Java / Kotlin | Easy |
| 04 | [二维数组中的查找](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/%E5%89%91%E6%8C%87offer/0xF04%20LeetCode%20%E5%89%91%E6%8C%87%20offer%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md)| [中文地址](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)| Java / Kotlin | Easy |
| 05 | [替换空格](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/%E5%89%91%E6%8C%87offer/0xF05%20LeetCode%20%E5%89%91%E6%8C%87%20offer%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.md)| [中文地址](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)| Java / Kotlin | Easy |
| 06 | [从尾到头打印链表](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/%E5%89%91%E6%8C%87offer/0xF06%20LeetCode%20%E5%89%91%E6%8C%87%20offer%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md)| [中文地址](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)| Java / Kotlin | Easy |
| 07 | [重建二叉树 ](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA05%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md)| [中文地址](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)| Java / Kotlin | Easy |

## 排序（编辑中）

排序：冒泡排序、插入排序、选择排序、希尔排序、归并排序、快速排序、堆排序

## 查找

查找：二分查找、线性查找、树结构查找、散列表查找

### 二分查找（持续更新中）

二分查找算法基本步骤：

1. 假定样本数列中的所有元素都是从小到大排列的。
2. 使用目标元素与样本数列中的中间元素进行大小的比较。
3. 若目标元素等于中间元素，则表示查找成功。
4. 若目标元素小于中间元素，则去中间元素的左侧进行查找，重复步骤 2。
5. 若目标元素大于中间元素，则去中间元素的右侧进行查找，重复步骤 2。
6. 直到与所有该比较的元素比较完毕依然不相等，则表示查找失败。

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-:  |   :-:  |   :-:    |   :-:      |
| 367 | [Valid Perfect Square<br/>有效的完全平方数](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/binarySearch(%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)/0xC01%20LeetCode%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.md)| [英文地址](https://leetcode.com/problems/valid-perfect-square/) / [中文地址](https://leetcode-cn.com/problems/valid-perfect-square/)| Java / Kotlin | Easy |
| 69 | [Sqrt(x)<br/>X的平方根](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/binarySearch(%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)/0xC02%20LeetCode%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9AX%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.md)| [英文地址](https://leetcode.com/problems/sqrtx/) / [中文地址](https://leetcode-cn.com/problems/sqrtx/)| Java / Kotlin | Easy |
| 744 | [Find Smallest Letter Greater Than Target<br/>寻找比目标字母大的最小字母](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/binarySearch(%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)/0xC03%20LeetCode%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D.md)| [英文地址](https://leetcode.com/problems/find-smallest-letter-greater-than-target/) / [中文地址](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)| Java / Kotlin | Easy |

### 线性查找（持续更新中）

从前往后依次对比需要查找的数据，如果找到对应的元素，则返回元素的位置。

   1. 使用目标元素与样本数列中的第一个元素起依次比较大小;
   2. 若找到与目标元素相等的元素，则表示查找成功；  
   3. 若目标元素与样本数列的所有元素比较完毕也没有找到相等的元素，则表示查找失败。

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-:  |   :-:  |   :-:    |   :-:      |
| 04 | [二维数组中的查找](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/%E5%89%91%E6%8C%87offer/0xF04%20LeetCode%20%E5%89%91%E6%8C%87%20offer%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.md)| [中文地址](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)| Java / Kotlin | Easy |

# 二叉树（持续更新中）

**完全二叉树：** 若二叉树的高度是h，除第h层之外，其他（1~h-1）层的节点数都达到了最大个数，并且第h层的节点都连续的集中在最左边。想到点什么没？实际上，完全二叉树和堆联系比较紧密哈~~~

**满二叉树：** 除最后一层外，每一层上的所有节点都有两个子节点，最后一层都是叶子节点。

**哈夫曼树：** 给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。

**二叉排序树：** 又称二叉查找树（Binary Search Tree），亦称二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

* 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
* 左、右子树也分别为二叉排序树；
* 没有键值相等的节点

二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找）

**平衡二叉树：** 又称 AVL 树。平衡二叉树是二叉搜索树的进化版，所谓平衡二叉树指的是，左右两个子树的高度差的绝对值不超过 1。

**红黑树：** 红黑树是每个节点都带颜色的树，节点颜色或是红色或是黑色，红黑树是一种查找树。红黑树有一个重要的性质，从根节点到叶子节点的最长的路径不多于最短的路径的长度的两倍。对于红黑树，插入，删除，查找的复杂度都是O（log N）。

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-: | :-: | :-: | :-: |
| 144 | [Binary Tree Preorder Traversal<br/>二叉树前序遍历](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA01%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%20%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.md)| [英文地址](https://leetcode.com/problems/binary-tree-preorder-traversal/) / [中文地址](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)| Java / Kotlin | Medium |
| 94 | [Binary Tree Inorder Traversal<br/>二叉树中序遍历](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA02%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.md) | [英文地址](https://leetcode.com/problems/binary-tree-inorder-traversal/) / [中文地址](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | Java / Kotlin | Medium |
| 145 | [Binary Tree Postorder Traversal<br/>二叉树后序遍历](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA03%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.md) | [英文地址](https://leetcode.com/problems/binary-tree-postorder-traversal/) / [中文地址](https://leetcode.com-cn/problems/binary-tree-postorder-traversal/) | Java / Kotlin | Medium |
| 145 | [Binary Tree Level Order Traversal<br/>二叉树层次遍历](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA04%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.md) | [英文地址](https://leetcode.com/problems/binary-tree-level-order-traversal/) / [中文地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) | Java / Kotlin | Medium |
| 107 | [Binary Tree Level Order Traversal II<br/>自下而上分层遍历](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA09%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E5%B1%82%E9%81%8D%E5%8E%86.md) | [英文地址](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/) / [中文地址](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) | Java / Kotlin | Easy |
| 105 | [Construct Binary Tree from Preorder and Inorder Traversal<br/>从前序与中序遍历序列构造二叉树](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA05%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md) | [英文地址](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) / [中文地址](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | Java / Kotlin | Medium |
| 104 | [Maximum Depth of Binary Tree<br/>计算二叉树的最大深度 ](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA06%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.md) | [英文地址](https://leetcode.com/problems/maximum-depth-of-binary-tree/) / [中文地址](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) | Java / Kotlin | Easy |
| 111 | [Minimum Depth of Binary Tree<br/>计算二叉树的最小深度](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA07%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.md) | [英文地址](https://leetcode.com/problems/minimum-depth-of-binary-tree/) / [中文地址](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) | Java / Kotlin | Easy |
| 110 | [Balanced Binary Tree<br/>判断二叉树是不是平衡二叉树](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA08%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.md) | [英文地址](https://leetcode.com/problems/balanced-binary-tree/) / [中文地址](https://leetcode-cn.com/problems/balanced-binary-tree/) | Java / Kotlin | Easy |
| 222 | [Count Complete Tree Nodes<br/>求二叉树中的节点个数](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA10%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.md) | [英文地址](https://leetcode.com/problems/count-complete-tree-nodes/) / [中文地址](https://leetcode-cn.com/problems/count-complete-tree-nodes/) | Java / Kotlin | Medium |
| 100 | [same-tree<br/>判断两棵二叉树是否结构相同](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/BinaryTree(%E4%BA%8C%E5%8F%89%E6%A0%91)/0xA11%20LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%88%A4%E6%96%AD%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%BB%93%E6%9E%84%E7%9B%B8%E5%90%8C.md) | [英文地址](https://leetcode.com/problems/same-tree/) / [中文地址](https://leetcode-cn.com/problems/same-tree/) | Java / Kotlin | Easy |

## 线性表

线性表：数组、链表、栈、队列等等

### 数组以及数字（持续更新中）

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-:  |   :-:  |   :-:    |   :-:      | 
| 01 | [拿硬币](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/Array(%E6%95%B0%E7%BB%84)/0xB01%20LeetCode%E6%95%B0%E7%BB%84%EF%BC%9A2020%20%E5%8A%9B%E6%89%A3%E6%9D%AF%EF%BC%9A%E6%8B%BF%E7%A1%AC%E5%B8%81.md)|  [中文地址](https://leetcode-cn.com/contest/season/2020-spring/problems/na-ying-bi/)| Java / Kotlin | Easy |
| 167 | [Two Sum II - Input array is sorted<br/>两数之和2 - 输入数组有序](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/Array(%E6%95%B0%E7%BB%84)/0xB02%20LeetCode%E6%95%B0%E7%BB%84%EF%BC%9A%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2%20-%20%E8%BE%93%E5%85%A5%E6%95%B0%E7%BB%84%E6%9C%89%E5%BA%8F.md)| [英文地址](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) / [中文地址](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)| Java / Kotlin | Easy |

### 链表（未编辑）

链表：单链表、双向链表、循环链表、双向循环链表、静态链表

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-: | :-: | :-: | :-: |
| 06 | [从尾到头打印链表](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin/blob/master/%E5%89%91%E6%8C%87offer/0xF06%20LeetCode%20%E5%89%91%E6%8C%87%20offer%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.md)| [中文地址](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)| Java / Kotlin | Easy |


### 栈（未编辑）

栈：顺序栈、链式栈

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-: | :-: | :-: | :-: |

### 队列（未编辑）

队列：普通队列、双端队列、阻塞队列、并发队列、阻塞并发队列

| 题号 | 题解 | 题目地址 | Lanuage | Difficulty |
| :-: | :-: | :-: | :-: | :-: |

## 结语

致力于分享一系列的Android系统源码、逆向分析、算法相关的文章，如果你同我一样喜欢算法、LeetCode，可以关注我 GitHub 上的 LeetCode 题解：[Leetcode-Solutions-with-Java-And-Kotlin](https://github.com/hi-dhl/Leetcode-Solutions-with-Java-And-Kotlin)，一起来学习，期待与你一起成长



